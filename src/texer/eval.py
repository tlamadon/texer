"""Evaluation engine for texer specs and LaTeX elements."""

from __future__ import annotations

import subprocess
from datetime import datetime
from typing import Any, Protocol, runtime_checkable

from texer.specs import Spec, resolve_value, Raw
from texer.utils import escape_latex


def _get_git_sha() -> str | None:
    """Get the full SHA of the current git commit.

    Returns:
        Full git SHA string, or None if not in a git repo or git unavailable.
    """
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None


def _get_version() -> str:
    """Get the texer version.

    Returns:
        Version string.
    """
    from texer import __version__

    return __version__


def _generate_header() -> str:
    """Generate a LaTeX comment header with version, creation date, and git SHA.

    Returns:
        LaTeX comment string with metadata.
    """
    version = _get_version()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    git_sha = _get_git_sha()

    lines = [f"% Generated by texer v{version} on {timestamp}"]
    if git_sha:
        lines.append(f"% Git commit: {git_sha}")

    return "\n".join(lines) + "\n"


@runtime_checkable
class Renderable(Protocol):
    """Protocol for objects that can render to LaTeX."""

    def render(self, data: Any, scope: dict[str, Any] | None = None) -> str:
        """Render this object to LaTeX string."""
        ...


def evaluate(
    element: Any,
    data: Any | None = None,
    scope: dict[str, Any] | None = None,
    escape: bool = True,
    header: bool = True,
) -> str:
    """Evaluate an element and return LaTeX string.

    This is the main entry point for converting texer elements to LaTeX.

    Args:
        element: The element to evaluate (Spec, Renderable, or plain value).
        data: The data context for resolving specs.
        scope: Additional scope variables.
        escape: Whether to escape LaTeX special characters in strings.
        header: Whether to include a header comment with creation date and git SHA.

    Returns:
        LaTeX string representation.

    Examples:
        >>> from texer import Ref, Table, Tabular, Row
        >>> data = {"name": "Alice", "value": 42}
        >>> evaluate(Ref("name"), data)
        'Alice'
    """
    if data is None:
        data = {}

    if scope is None:
        scope = {}

    result = _evaluate_impl(element, data, scope, escape)

    if header:
        result = _generate_header() + result

    return result


def _evaluate_impl(
    element: Any,
    data: Any,
    scope: dict[str, Any],
    escape: bool,
) -> str:
    """Internal implementation of evaluate."""
    # Handle None
    if element is None:
        return ""

    # Handle Raw specs (don't escape)
    if isinstance(element, Raw):
        return element.resolve(data, scope)

    # Handle Specs
    if isinstance(element, Spec):
        resolved = element.resolve(data, scope)
        return _evaluate_impl(resolved, data, scope, escape)

    # Handle Renderables (Table, Tabular, Row, etc.)
    if isinstance(element, Renderable):
        return element.render(data, scope)

    # Handle lists/tuples
    if isinstance(element, (list, tuple)):
        return "".join(_evaluate_impl(item, data, scope, escape) for item in element)

    # Handle plain values
    result = str(element)
    if escape:
        return escape_latex(result)
    return result


def evaluate_value(
    value: Any,
    data: Any,
    scope: dict[str, Any] | None = None,
) -> Any:
    """Evaluate a value without converting to string.

    This resolves Specs but doesn't convert to LaTeX string.
    Useful for getting raw values (lists, numbers, etc.)

    Args:
        value: The value to evaluate.
        data: The data context.
        scope: Additional scope variables.

    Returns:
        The resolved value (may be any type).
    """
    if scope is None:
        scope = {}

    return resolve_value(value, data, scope)


def _get_preamble(element: Any) -> list[str]:
    """Get the appropriate preamble for an element type.

    Args:
        element: The element to get preamble for.

    Returns:
        List of preamble lines.
    """
    # Check if element has a with_preamble method (like PGFPlot)
    if hasattr(element, "with_preamble"):
        # PGFPlot handles its own preamble
        return []

    # Check for table-related imports
    from texer.tables import Table, Tabular

    if isinstance(element, (Table, Tabular)):
        return [
            "\\documentclass{standalone}",
            "\\usepackage{booktabs}",
            "",
            "\\begin{document}",
        ]

    # Default preamble for unknown elements
    return [
        "\\documentclass{standalone}",
        "",
        "\\begin{document}",
    ]


def _wrap_with_preamble(element: Any, content: str, data: Any) -> str:
    """Wrap content with appropriate preamble.

    Args:
        element: The original element (for type detection).
        content: The rendered LaTeX content.
        data: Data dict for rendering.

    Returns:
        Complete LaTeX document string.
    """
    # If element has with_preamble, use it directly
    if hasattr(element, "with_preamble"):
        result: str = element.with_preamble(data)
        return result

    preamble = _get_preamble(element)
    closing = ["\\end{document}"]

    return "\n".join(preamble + [content] + closing)


def save_to_file(
    element: Any,
    file_path: str,
    data: Any = None,
    with_preamble: bool = True,
    header: bool = True,
) -> None:
    """Save an element to a LaTeX file.

    Args:
        element: The element to save (Table, PGFPlot, Tabular, etc.).
        file_path: Path to the output .tex file.
        data: Optional data dict for rendering (default: empty dict).
        with_preamble: Whether to include document preamble for standalone compilation (default: True).
        header: Whether to include a header comment with creation date and git SHA (default: True).

    Examples:
        # Save a table with preamble
        save_to_file(table, "my_table.tex")

        # Save just the table content (no preamble)
        save_to_file(table, "my_table.tex", with_preamble=False)

        # Save a plot with data
        save_to_file(plot, "my_plot.tex", data=my_data)
    """
    if data is None:
        data = {}

    if with_preamble:
        # For elements with with_preamble method, use it
        if hasattr(element, "with_preamble"):
            latex_code = element.with_preamble(data)
        else:
            # Render content and wrap with preamble
            content = _evaluate_impl(element, data, {}, escape=True)
            latex_code = _wrap_with_preamble(element, content, data)
    else:
        latex_code = _evaluate_impl(element, data, {}, escape=True)

    if header:
        latex_code = _generate_header() + latex_code

    with open(file_path, "w", encoding="utf-8") as f:
        f.write(latex_code)


def compile_to_pdf(
    element: Any,
    tex_file_path: str,
    data: Any = None,
    output_dir: str | None = None,
    header: bool = True,
) -> str:
    """Save an element to .tex file and compile to PDF using pdflatex.

    Args:
        element: The element to compile (Table, PGFPlot, Tabular, etc.).
        tex_file_path: Path to save the .tex file (e.g., "my_table.tex").
        data: Optional data dict for rendering (default: empty dict).
        output_dir: Optional output directory for compilation (default: same as .tex file).
        header: Whether to include a header comment with creation date and git SHA (default: True).

    Returns:
        Path to the generated PDF file.

    Raises:
        RuntimeError: If pdflatex is not available or compilation fails.

    Examples:
        # Compile a table to PDF
        pdf_path = compile_to_pdf(table, "my_table.tex")

        # Compile a plot with data
        pdf_path = compile_to_pdf(plot, "my_plot.tex", data=my_data)

        # Specify output directory
        pdf_path = compile_to_pdf(table, "my_table.tex", output_dir="/tmp")
    """
    import shutil
    from pathlib import Path

    # Check if pdflatex is available
    if shutil.which("pdflatex") is None:
        raise RuntimeError(
            "pdflatex not found. Please install a LaTeX distribution (e.g., TeX Live, MiKTeX)."
        )

    # Save to file with preamble
    save_to_file(element, tex_file_path, data=data, with_preamble=True, header=header)

    # Determine paths
    tex_path = Path(tex_file_path).resolve()
    output_path: Path
    if output_dir is None:
        output_path = tex_path.parent
    else:
        output_path = Path(output_dir).resolve()

    # Run pdflatex
    try:
        result = subprocess.run(
            [
                "pdflatex",
                "-interaction=nonstopmode",
                f"-output-directory={output_path}",
                str(tex_path),
            ],
            capture_output=True,
            text=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        raise RuntimeError(
            f"pdflatex compilation failed:\n{e.stderr}\n\nOutput:\n{e.stdout}"
        ) from e

    # Return path to PDF
    pdf_path = output_path / tex_path.with_suffix(".pdf").name
    return str(pdf_path)
