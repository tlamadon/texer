"""Evaluation engine for texer specs and LaTeX elements."""

from __future__ import annotations

import subprocess
from datetime import datetime
from typing import Any, Protocol, runtime_checkable

from texer.specs import Spec, resolve_value, Raw
from texer.utils import escape_latex


def _get_git_sha() -> str | None:
    """Get the full SHA of the current git commit.

    Returns:
        Full git SHA string, or None if not in a git repo or git unavailable.
    """
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None


def _get_version() -> str:
    """Get the texer version.

    Returns:
        Version string.
    """
    from texer import __version__

    return __version__


def _generate_header() -> str:
    """Generate a LaTeX comment header with version, creation date, and git SHA.

    Returns:
        LaTeX comment string with metadata.
    """
    version = _get_version()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    git_sha = _get_git_sha()

    lines = [f"% Generated by texer v{version} on {timestamp}"]
    if git_sha:
        lines.append(f"% Git commit: {git_sha}")

    return "\n".join(lines) + "\n"


@runtime_checkable
class Renderable(Protocol):
    """Protocol for objects that can render to LaTeX."""

    def render(self, data: Any, scope: dict[str, Any] | None = None) -> str:
        """Render this object to LaTeX string."""
        ...


def evaluate(
    element: Any,
    data: Any | None = None,
    scope: dict[str, Any] | None = None,
    escape: bool = True,
    header: bool = True,
) -> str:
    """Evaluate an element and return LaTeX string.

    This is the main entry point for converting texer elements to LaTeX.

    Args:
        element: The element to evaluate (Spec, Renderable, or plain value).
        data: The data context for resolving specs.
        scope: Additional scope variables.
        escape: Whether to escape LaTeX special characters in strings.
        header: Whether to include a header comment with creation date and git SHA.

    Returns:
        LaTeX string representation.

    Examples:
        >>> from texer import Ref, Table, Tabular, Row
        >>> data = {"name": "Alice", "value": 42}
        >>> evaluate(Ref("name"), data)
        'Alice'
    """
    if data is None:
        data = {}

    if scope is None:
        scope = {}

    result = _evaluate_impl(element, data, scope, escape)

    if header:
        result = _generate_header() + result

    return result


def _evaluate_impl(
    element: Any,
    data: Any,
    scope: dict[str, Any],
    escape: bool,
) -> str:
    """Internal implementation of evaluate."""
    # Handle None
    if element is None:
        return ""

    # Handle Raw specs (don't escape)
    if isinstance(element, Raw):
        return element.resolve(data, scope)

    # Handle Specs
    if isinstance(element, Spec):
        resolved = element.resolve(data, scope)
        return _evaluate_impl(resolved, data, scope, escape)

    # Handle Renderables (Table, Tabular, Row, etc.)
    if isinstance(element, Renderable):
        return element.render(data, scope)

    # Handle lists/tuples
    if isinstance(element, (list, tuple)):
        return "".join(_evaluate_impl(item, data, scope, escape) for item in element)

    # Handle plain values
    result = str(element)
    if escape:
        return escape_latex(result)
    return result


def evaluate_value(
    value: Any,
    data: Any,
    scope: dict[str, Any] | None = None,
) -> Any:
    """Evaluate a value without converting to string.

    This resolves Specs but doesn't convert to LaTeX string.
    Useful for getting raw values (lists, numbers, etc.)

    Args:
        value: The value to evaluate.
        data: The data context.
        scope: Additional scope variables.

    Returns:
        The resolved value (may be any type).
    """
    if scope is None:
        scope = {}

    return resolve_value(value, data, scope)
